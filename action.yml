name: 'AWS Lambda Python Function'
description: 'Deploy a Python function to AWS Lambda'
author: 'alonch'
branding:
  icon: 'cloud-lightning'
  color: 'blue'

inputs:
  action:
    description: 'Desired outcome: apply, plan or destroy'
    required: false
    default: 'apply'
  name:
    description: 'Function name'
    required: true
  arm:
    description: 'Run in ARM compute'
    required: false
    default: 'true'
  python-version:
    description: 'Python version. Supported versions: 3.8, 3.9, 3.10, 3.11, 3.12'
    required: false
    default: '3.11'
  entrypoint-file:
    description: 'Path to entry file'
    required: true
  entrypoint-function:
    description: 'Function on the entrypoint-file to handle events'
    required: true
  memory:
    description: '128 (in MB) to 10,240 (in MB)'
    required: false
    default: '128'
  env:
    description: 'List of environment variables in YML format'
    required: false
    default: 'CREATE_BY: alonch/actions-aws-function-python'
  permissions:
    description: 'List of permissions following Github standard of service: read or write. In YML format'
    required: false
    default: ''
  artifacts:
    description: 'This folder will be zip and deploy to Lambda'
    required: false
    default: ''
  timeout:
    description: 'Maximum time in seconds before aborting the execution'
    required: false
    default: '3'
  allow-public-access:
    description: 'Generate a public URL. WARNING: ANYONE ON THE INTERNET CAN RUN THIS FUNCTION'
    required: false
    default: ''
  volume-name:
    description: 'Name of the EFS volume to create or reuse. If an EFS with this name (as a tag) exists, it will be reused.'
    required: false
    default: ''
  volume-path:
    description: 'Path where the EFS volume should be mounted (e.g., /mnt/data). Defaults to /mnt/{volume-name}.'
    required: false
    default: ''

outputs:
  arn:
    description: 'ARN of the deployed Lambda function'
    value: ${{ steps.terraform.outputs.arn }}
  url:
    description: 'Public accessible URL, if allow-public-access=true'
    value: ${{ steps.terraform.outputs.url }}
  efs_filesystem_id:
    description: 'ID of the EFS file system (if using EFS)'
    value: ${{ steps.terraform.outputs.efs_filesystem_id }}
  efs_access_point_id:
    description: 'ID of the EFS access point (if using EFS)'
    value: ${{ steps.terraform.outputs.efs_access_point_id }}
  efs_mount_path:
    description: 'Path where the EFS volume is mounted (if using EFS)'
    value: ${{ steps.terraform.outputs.efs_mount_path }}
  efs_is_reused:
    description: 'Whether an existing EFS file system was reused'
    value: ${{ steps.terraform.outputs.efs_is_reused }}

runs:
  using: "composite"
  steps:
    - name: Discover existing EFS by tag
      if: inputs.volume-name != ''
      run: |
        echo "Checking for existing EFS with volume-name tag: ${{ inputs.volume-name }}"

        # Use AWS CLI to find EFS with matching tag
        EXISTING_EFS=$(aws efs describe-file-systems \
          --query "FileSystems[?Tags[?Key=='volume-name' && Value=='${{ inputs.volume-name }}']].FileSystemId" \
          --output text)

        if [ -n "$EXISTING_EFS" ]; then
          # If multiple results, just take the first one
          EFS_ID=$(echo $EXISTING_EFS | awk '{print $1}')
          echo "Found existing EFS with ID: $EFS_ID"
          echo "EXISTING_EFS_ID=$EFS_ID" >> $GITHUB_ENV
          echo "EFS_REUSED=true" >> $GITHUB_ENV
        else
          echo "No existing EFS found with tag volume-name=${{ inputs.volume-name }}"
          echo "EXISTING_EFS_ID=" >> $GITHUB_ENV
          echo "EFS_REUSED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Terraform init
      run: |
        terraform init \
          -backend-config="bucket=$TF_BACKEND_s3" \
          -backend-config="dynamodb_table=$TF_BACKEND_dynamodb" \
          -backend-config="key=$TF_BACKEND_key"
      shell: bash
      working-directory: ${{ github.action_path }}
      env:
        TF_BACKEND_key: "actions-aws-function-python/${{ inputs.name }}"
        TF_VAR_name: ${{ inputs.name }}
        TF_VAR_arm: ${{ inputs.arm }}
        TF_VAR_python_version: ${{ inputs.python-version }}
        TF_VAR_entrypoint_file: ${{ inputs.entrypoint-file }}
        TF_VAR_entrypoint_function: ${{ inputs.entrypoint-function }}
        TF_VAR_memory: ${{ inputs.memory }}
        TF_VAR_timeout: ${{ inputs.timeout }}
        TF_VAR_allow_public_access: ${{ inputs.allow-public-access }}
        TF_VAR_artifacts: ${{ github.workspace }}/${{ inputs.artifacts }}
        TF_VAR_env: ${{ inputs.env }}
        TF_VAR_permissions: ${{ inputs.permissions }}
        TF_VAR_volume_name: ${{ inputs.volume-name }}
        TF_VAR_volume_path: ${{ inputs.volume-path }}
        TF_VAR_existing_efs_id: ${{ env.EXISTING_EFS_ID }}

    - name: Terraform plan
      if: inputs.action == 'plan'
      run: terraform plan
      shell: bash
      working-directory: ${{ github.action_path }}
      env:
        TF_VAR_name: ${{ inputs.name }}
        TF_VAR_arm: ${{ inputs.arm }}
        TF_VAR_python_version: ${{ inputs.python-version }}
        TF_VAR_entrypoint_file: ${{ inputs.entrypoint-file }}
        TF_VAR_entrypoint_function: ${{ inputs.entrypoint-function }}
        TF_VAR_memory: ${{ inputs.memory }}
        TF_VAR_timeout: ${{ inputs.timeout }}
        TF_VAR_allow_public_access: ${{ inputs.allow-public-access }}
        TF_VAR_artifacts: ${{ github.workspace }}/${{ inputs.artifacts }}
        TF_VAR_env: ${{ inputs.env }}
        TF_VAR_permissions: ${{ inputs.permissions }}
        TF_VAR_volume_name: ${{ inputs.volume-name }}
        TF_VAR_volume_path: ${{ inputs.volume-path }}
        TF_VAR_existing_efs_id: ${{ env.EXISTING_EFS_ID }}

    - name: Terraform destroy
      if: inputs.action == 'destroy'
      run: terraform destroy -auto-approve
      shell: bash
      working-directory: ${{ github.action_path }}
      env:
        TF_VAR_name: ${{ inputs.name }}
        TF_VAR_arm: ${{ inputs.arm }}
        TF_VAR_python_version: ${{ inputs.python-version }}
        TF_VAR_entrypoint_file: ${{ inputs.entrypoint-file }}
        TF_VAR_entrypoint_function: ${{ inputs.entrypoint-function }}
        TF_VAR_memory: ${{ inputs.memory }}
        TF_VAR_timeout: ${{ inputs.timeout }}
        TF_VAR_allow_public_access: ${{ inputs.allow-public-access }}
        TF_VAR_artifacts: ${{ github.workspace }}/${{ inputs.artifacts }}
        TF_VAR_env: ${{ inputs.env }}
        TF_VAR_permissions: ${{ inputs.permissions }}
        TF_VAR_volume_name: ${{ inputs.volume-name }}
        TF_VAR_volume_path: ${{ inputs.volume-path }}
        TF_VAR_existing_efs_id: ${{ env.EXISTING_EFS_ID }}

    - name: Terraform apply
      id: terraform
      if: inputs.action == 'apply'
      run: |
        terraform apply -auto-approve
        ARN=$(terraform output -raw lambda_arn | tr -d '\r\n')
        URL=$(terraform output -raw lambda_url | tr -d '\r\n')
        EFS_ID=$(terraform output -raw efs_filesystem_id | tr -d '\r\n')
        EFS_AP=$(terraform output -raw efs_access_point_id | tr -d '\r\n')
        EFS_PATH=$(terraform output -raw efs_mount_path | tr -d '\r\n')

        # Use the EFS_REUSED value from our discovery step
        EFS_REUSED="${{ env.EFS_REUSED }}"

        # Set outputs properly
        echo "arn=$ARN" >> "$GITHUB_OUTPUT"
        echo "url=$URL" >> "$GITHUB_OUTPUT"
        echo "efs_filesystem_id=$EFS_ID" >> "$GITHUB_OUTPUT"
        echo "efs_access_point_id=$EFS_AP" >> "$GITHUB_OUTPUT"
        echo "efs_mount_path=$EFS_PATH" >> "$GITHUB_OUTPUT"
        echo "efs_is_reused=$EFS_REUSED" >> "$GITHUB_OUTPUT"
      shell: bash
      working-directory: ${{ github.action_path }}
      env:
        TF_VAR_name: ${{ inputs.name }}
        TF_VAR_arm: ${{ inputs.arm }}
        TF_VAR_python_version: ${{ inputs.python-version }}
        TF_VAR_entrypoint_file: ${{ inputs.entrypoint-file }}
        TF_VAR_entrypoint_function: ${{ inputs.entrypoint-function }}
        TF_VAR_memory: ${{ inputs.memory }}
        TF_VAR_timeout: ${{ inputs.timeout }}
        TF_VAR_allow_public_access: ${{ inputs.allow-public-access }}
        TF_VAR_artifacts: ${{ github.workspace }}/${{ inputs.artifacts }}
        TF_VAR_env: ${{ inputs.env }}
        TF_VAR_permissions: ${{ inputs.permissions }}
        TF_VAR_volume_name: ${{ inputs.volume-name }}
        TF_VAR_volume_path: ${{ inputs.volume-path }}
        TF_VAR_existing_efs_id: ${{ env.EXISTING_EFS_ID }}